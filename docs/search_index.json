[["intro.html", "Chapter 2 Introduction to Visualization 2.1 Data 2.2 Basic principles of {ggplot2} 2.3 Create plots with {ggplot2} 2.4 To go further", " Chapter 2 Introduction to Visualization The follow was adapted from Antonie Soeteweys blog post. R is known to be a really powerful programming language when it comes to graphics and visualizations. To keep it short, graphics in R can be done in three ways, via the: {graphics} package (the base graphics in R, loaded by default) {lattice} package which adds more functionalities to the base package {ggplot2} package The {graphics} package comes with a large choice of plots (such as plot, hist, barplot, boxplot, pie, mosaicplot, etc.) and additional related features (e.g., abline, lines, legend, mtext, rect, etc.). It is often the preferred way to draw plots for most R users, and in particular for beginners to intermediate users. Since its creation in 2005 by Hadley Wickham, {ggplot2} has grown in use to become one of the most popular R packages and the most popular package for graphics and data visualizations. The {ggplot2} package is a much more modern approach to creating professional-quality graphics. More information about the package can be found at ggplot2.tidyverse.org. In this article, we will see how to create common plots such as scatter plots, line plots, histograms, boxplots, barplots, density plots in R with this package. 2.1 Data To illustrate plots with the {ggplot2} package we will use the mpg dataset available in the package. The dataset contains observations collected by the US Environmental Protection Agency on fuel economy from 1999 to 2008 for 38 popular models of cars (run ?mpg for more information about the data): library(ggplot2) dat &lt;- ggplot2::mpg Before going further, lets transform the cyl, drv, fl, year and class variables in with the transform() function: dat &lt;- transform(dat, cyl = factor(cyl), drv = factor(drv), fl = factor(fl), year = factor(year), class = factor(class) ) 2.2 Basic principles of {ggplot2} The {ggplot2} package is based on the principles of The Grammar of Graphics (hence gg in the name of {ggplot2}), that is, a coherent system for describing and building graphs. The main idea is to design a graphic as a succession of layers. The main layers are: The dataset that contains the variables that we want to represent. This is done with the ggplot() function and comes first. The variable(s) to represent on the x and/or y-axis, and the aesthetic elements (such as color, size, fill, shape and transparency) of the objects to be represented. This is done with the aes() function (abbreviation of aesthetic). The type of graphical representation (scatter plot, line plot, barplot, histogram, boxplot, etc.). This is done with the functions geom_point(), geom_line(), geom_bar(), geom_histogram(), geom_boxplot(), etc. If needed, additional layers (such as labels, annotations, scales, axis ticks, legends, themes, facets, etc.) can be added to personalize the plot. To create a plot, we thus first need to specify the data in the ggplot() function and then add the required layers such as the variables, the aesthetic elements and the type of plot: ggplot(data) + aes(x = var_x, y = var_y) + geom_x() data in ggplot() is the name of the data frame which contains the variables var_x and var_y. The + symbol is used to indicate the different layers that will be added to the plot. Make sure to write the + symbol at the end of the line of code and not at the beginning of the line, otherwise R throws an error. The layer aes() indicates what variables will be used in the plot and more generally, the aesthetic elements of the plot. Finally, x in geom_x() represents the type of plot. Other layers are usually not required unless we want to personalize the plot further. Note that it is a good practice to write one line of code per layer to improve code readability. 2.3 Create plots with {ggplot2} In the following sections we will show how to draw the following plots: scatter plot line plot histogram density plot boxplot barplot In order to focus on the construction of the different plots and the use of {ggplot2}, we will restrict ourselves to drawing basic (yet beautiful) plots without unnecessary layers. For the sake of completeness, we will briefly discuss and illustrate different layers to further personalize a plot at end of this section. Note that if you still struggle to create plots with {ggplot2} after reading this tutorial, you may find the {esquisse} addin useful. This addin allows you to interactively (that is, by dragging and dropping variables) create plots with the {ggplot2} package. Give it a try! 2.3.1 Scatter plot We start by creating a scatter plot using geom_point. Remember that a scatter plot is used to visualize the relation between two quantitative variables]. We start by specifying the data: ggplot(dat) # data Then we add the variables to be represented with the aes() function: ggplot(dat) + # data aes(x = displ, y = hwy) # variables Finally, we indicate the type of plot: ggplot(dat) + # data aes(x = displ, y = hwy) + # variables geom_point() # type of plot You will also sometimes see the aesthetic elements (aes() with the variables) inside the ggplot() function in addition to the dataset: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() This second method gives the exact same plot than the first method. I tend to prefer the first method over the second for better readability, but this is more a matter of taste so the choice is up to you. 2.3.2 Line plot Line plots, particularly useful in time series or finance, can be created similarly but by using geom_line(): ggplot(dat) + aes(x = displ, y = hwy) + geom_line() 2.3.3 Combination of line and points An advantage of {ggplot2} is the ability to combine several types of plots and its flexibility in designing it. For instance, we can add a line to a scatter plot by simply adding a layer to the initial scatter plot: ggplot(dat) + aes(x = displ, y = hwy) + geom_point() + geom_line() # add line 2.3.4 Histogram A histogram (useful to visualize distributions and detect potential outliers can be plotted using geom_histogram(): ggplot(dat) + aes(x = hwy) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. By default, the number of bins is equal to 30. You can change this value using the bins argument inside the geom_histogram() function: ggplot(dat) + aes(x = hwy) + geom_histogram(bins = sqrt(nrow(dat))) Here I specify the number of bins to be equal to the square root of the number of observations (following Sturges rule) but you can specify any numeric value. 2.3.5 Density plot Density plotscan be created using geom_density(): ggplot(dat) + aes(x = hwy) + geom_density() 2.3.6 Combination of histogram and densities We can also superimpose a histogram and a density curve on the same plot: ggplot(dat) + aes(x = hwy, y = ..density..) + geom_histogram() + geom_density() ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. Or superimpose several densities: ggplot(dat) + aes(x = hwy, color = drv, fill = drv) + geom_density(alpha = 0.25) # add transparency The argument alpha = 0.25 has been added for some transparency. More information about this argument can be found in at the end. 2.3.7 Boxplot A boxplot (also very useful to visualize distributions and detect potential outliers can be plotted using geom_boxplot(): # Boxplot for one variable ggplot(dat) + aes(x = &quot;&quot;, y = hwy) + geom_boxplot() # Boxplot by factor ggplot(dat) + aes(x = drv, y = hwy) + geom_boxplot() It is also possible to plot the points on the boxplot with geom_jitter(), and to vary the width of the boxes according to the size (i.e., the number of observations) of each level with varwidth = TRUE: ggplot(dat) + aes(x = drv, y = hwy) + geom_boxplot(varwidth = TRUE) + # vary boxes width according to n obs. geom_jitter(alpha = 0.25, width = 0.2) # adds random noise and limit its width The geom_jitter() layer adds some random variation to each point in order to prevent them from overlapping (an issue known as overplotting).1 Moreover, the alpha argument adds some transparency to the points to keep the focus on the boxes and not on the points. Finally, it is also possible to divide boxplots into several panels according to the levels of a qualitative variable: ggplot(dat) + aes(x = drv, y = hwy) + geom_boxplot(varwidth = TRUE) + # vary boxes width according to n obs. geom_jitter(alpha = 0.25, width = 0.2) + # adds random noise and limit its width facet_wrap(~year) # divide into 2 panels For a visually more appealing plot, it is also possible to use some colors for the boxes depending on the x variable: ggplot(dat) + aes(x = drv, y = hwy, fill = drv) + # add color to boxes with fill geom_boxplot(varwidth = TRUE) + # vary boxes width according to n obs. geom_jitter(alpha = 0.25, width = 0.2) + # adds random noise and limit its width facet_wrap(~year) + # divide into 2 panels theme(legend.position = &quot;none&quot;) # remove legend In that case, it best to remove the legend as it becomes redundant. See more information about the legend later on. If you are unhappy with the default colors provided in {ggplot2}, you can change them manually with the scale_fill_manual() layer: ggplot(dat) + aes(x = drv, y = hwy, fill = drv) + # add color to boxes with fill geom_boxplot(varwidth = TRUE) + # vary boxes width according to n obs. geom_jitter(alpha = 0.25, width = 0.2) + # adds random noise and limit its width facet_wrap(~year) + # divide into 2 panels theme(legend.position = &quot;none&quot;) + # remove legend scale_fill_manual(values = c(&quot;darkred&quot;, &quot;darkgreen&quot;, &quot;steelblue&quot;)) # change fill color manually 2.3.8 Barplot A barplot (useful to visualize qualitative variables) can be plotted using geom_bar(): ggplot(dat) + aes(x = drv) + geom_bar() By default, the heights of the bars correspond to the observed frequencies for each level of the variable of interest (drv in our case). Again, for a more appealing plot, we can add some colors to the bars with the fill argument: ggplot(dat) + aes(x = drv, fill = drv) + # add colors to bars geom_bar() + theme(legend.position = &quot;none&quot;) # remove legend We can also create a barplot with two qualitative variables: ggplot(dat) + aes(x = drv, fill = year) + # fill by years geom_bar() In order to compare proportions across groups, it is best to make each bar the same height using position = \"fill\": ggplot(dat) + geom_bar(aes(x = drv, fill = year), position = &quot;fill&quot;) To draw the bars next to each other for each group, use position = \"dodge\": ggplot(dat) + geom_bar(aes(x = drv, fill = year), position = &quot;dodge&quot;) 2.3.9 Further personalization 2.3.9.1 Title and axis labels The first things to personalize in a plot is the labels to make the plot more informative to the audience. We can easily add a title, subtitle, caption and edit axis labels with the labs() function: p &lt;- ggplot(dat) + aes(x = displ, y = hwy) + geom_point() p + labs( title = &quot;Fuel efficiency for 38 popular models of car&quot;, subtitle = &quot;Period 1999-2008&quot;, caption = &quot;Data: ggplot2::mpg. See more at statsandr.com&quot;, x = &quot;Engine displacement (litres)&quot;, y = &quot;Highway miles per gallon (mpg)&quot; ) As you can see in the above code, you can save one or more layers of the plot in an object for later use. This way, you can save your main plot, and add more layers of personalization until you get the desired output. Here we saved the main scatter plot in an object called p and we will refer to it for the subsequent personalizations. You can also edit the alignment, the size and the shape of the title and subtitle via the theme() layer and the element_text() function: p + labs( title = &quot;Fuel efficiency for 38 popular models of car&quot;, subtitle = &quot;Period 1999-2008&quot;, caption = &quot;Data: ggplot2::mpg. See more at statsandr.com&quot;, x = &quot;Engine displacement (litres)&quot;, y = &quot;Highway miles per gallon (mpg)&quot; ) + theme( plot.title = element_text( hjust = 0.5, # center size = 12, color = &quot;steelblue&quot;, face = &quot;bold&quot; ), plot.subtitle = element_text( hjust = 0.5, # center size = 10, color = &quot;gray&quot;, face = &quot;italic&quot; ) ) If the title or subtitle is long and you want to divide it into multiple lines, use \\n: p + labs( title = &quot;Fuel efficiency for 38 popular \\n models of car&quot;, subtitle = &quot;Period 1999-2008&quot;, caption = &quot;Data: ggplot2::mpg. See more at statsandr.com&quot;, x = &quot;Engine displacement (litres)&quot;, y = &quot;Highway miles per gallon (mpg)&quot; ) + theme( plot.title = element_text( hjust = 0.5, # center size = 12, color = &quot;steelblue&quot;, face = &quot;bold&quot; ), plot.subtitle = element_text( hjust = 0.5, # center size = 10, color = &quot;gray&quot;, face = &quot;italic&quot; ) ) 2.3.9.2 Axis ticks Axis ticks can be adjusted using scale_x_continuous() and scale_y_continuous() for the x and y-axis, respectively: # Adjust ticks p + scale_x_continuous(breaks = seq(from = 1, to = 7, by = 0.5)) + # x-axis scale_y_continuous(breaks = seq(from = 10, to = 45, by = 5)) # y-axis 2.3.9.3 Log transformations In some cases, it is useful to plot the log transformation of the variables. This can be done with the scale_x_log10() and scale_y_log10() functions: p + scale_x_log10() + scale_y_log10() 2.3.9.4 Limits The most convenient way to control the limits of the plot is to use again the scale_x_continuous() and scale_y_continuous() functions in addition to the limits argument: p + scale_x_continuous(limits = c(3, 6)) + scale_y_continuous(limits = c(20, 30)) ## Warning: Removed 181 rows containing missing values (geom_point). It is also possible to simply take a subset of the dataset with the subset() or filter() function. See how to subset a dataset if you need a reminder. 2.3.9.5 Legend By default, the legend is located to the right side of the plot (when there is a legend to be displayed of course). To control the position of the legend, we need to use the theme() function in addition to the legend.position argument: p + aes(color = class) + theme(legend.position = &quot;top&quot;) Replace \"top\" by \"left\" or \"bottom\" to change its position and by \"none\" to remove it. The title of the legend can be edited with the labs() layer: p + aes(color = class) + labs(color = &quot;Car&#39;s class&quot;) Note that the argument inside labs() must match the one inside the aes() layer (in this case: color). The title of the legend can also be removed with legend.title = element_blank() inside the theme() layer: p + aes(color = class) + theme( legend.title = element_blank(), legend.position = &quot;bottom&quot; ) The legend now appears at the bottom of the plot, without the legend title. 2.3.9.6 Shape, color, size and transparency There are a very large number of options to improve the quality of the plot or to add additional information. These include: shape, size, color, and alpha (transparency). We can for instance change the shape of all points in a scatter plot by adding shape to geom_point(), or vary the shape according to the values taken by another variable (in that case, the shape argument must be inside aes()):2 # Change shape of all points ggplot(dat) + aes(x = displ, y = hwy) + geom_point(shape = 4) # Change shape of points based on a categorical variable ggplot(dat) + aes(x = displ, y = hwy, shape = drv) + geom_point() Following the same principle, we can modify the color, size and transparency of the points based on a qualitative or quantitative variable. Here are some examples: p &lt;- ggplot(dat) + aes(x = displ, y = hwy) + geom_point() # Change color for all points p + geom_point(color = &quot;steelblue&quot;) # Change color based on a qualitative variable p + aes(color = drv) # Change color based on a quantitative variable p + aes(color = cty) # Change color based on a criterion (median of cty variable) p + aes(color = cty &gt; median(cty)) # Change size of all points p + geom_point(size = 4) # Change size of points based on a quantitative variable p + aes(size = cty) # Change transparency based on a quantitative variable p + aes(alpha = cty) We can of course mix several options (shape, color, size, alpha) to build more complex graphics: p + geom_point(size = 0.5) + aes(color = drv, shape = year, alpha = cty) If you are unhappy with the default colors, you can change them manually with the scale_colour_manual() layer (for qualitative variables) and the scale_coulour_gradient2() layer (for quantitative variables): # Change color based on a qualitative variable p + aes(color = drv) + scale_colour_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) # Change color based on a quantitative variable p + aes(color = cty) + scale_colour_gradient2( low = &quot;green&quot;, mid = &quot;gray&quot;, high = &quot;red&quot;, midpoint = median(dat$cty) ) 2.3.9.7 Text and labels To add a label on a point (for example the row number), we can use the geom_text() and aes() functions: p + geom_text(aes(label = rownames(dat)), check_overlap = TRUE, size = 2, vjust = -1 ) To add text on the plot, we use the annotate() function: p + annotate(&quot;text&quot;, x = 6, y = 40, label = &quot;hwy and displ are \\n negatively correlated \\n (rho = -0.77, p-value &lt; 0.001)&quot;, size = 3 ) 2.3.9.8 Smooth and regression lines In a scatter plot, it is possible to add a smooth line fitted to the data: p + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; In the context of simple linear regression, it is often the case that the regression line is displayed on the plot. This can be done by adding method = lm (lm stands for linear model) in the geom_smooth() layer: p + geom_smooth(method = lm) ## `geom_smooth()` using formula &#39;y ~ x&#39; It is also possible to draw a regression line for each level of a categorical variable: p + aes(color = drv, shape = drv) + geom_smooth(method = lm, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; The se = FALSE argument removes the confidence interval around the regression lines. 2.3.9.9 Facets facet_grid allows you to divide the same graphic into several panels according to the values of one or two qualitative variables: # According to one variable p + facet_grid(. ~ drv) # According to 2 variables p + facet_grid(drv ~ year) It is then possible to add a regression line to each facet: p + facet_grid(. ~ drv) + geom_smooth(method = lm) ## `geom_smooth()` using formula &#39;y ~ x&#39; 2.3.9.10 Themes Several functions are available in the {ggplot2} package to change the theme of the plot. The most common themes after the default theme (i.e., theme_gray()) are the black and white (theme_bw()), minimal (theme_minimal()) and classic (theme_classic()) themes: # Black and white theme p + theme_bw() # Minimal theme p + theme_minimal() # Classic theme p + theme_classic() I tend to use the minimal theme for most of my R Markdown reports as it brings out the patterns and points and not the layout of the plot, but again this is a matter of personal taste. See more themes at ggplot2.tidyverse.org/reference/ggtheme.html and in the {ggthemes} package. In order to avoid having to change the theme for each plot you create, you can change the theme for the current R session using the theme_set() function as follows: theme_set(theme_minimal()) 2.3.9.11 Interactive plot with {plotly} You can easily make your plots created with {ggplot2} interactive with the {plotly} package: library(plotly) ggplotly(p + aes(color = year)) You can now hover over a point to display more information about that point. There is also the possibility to zoom in and out, to download the plot, to select some observations, etc. More information about {plotly} for R can be found here. 2.3.9.12 Combine plots with {patchwork} There are several ways to combine plots made in {ggplot2}. In my opinion, the most convenient way is with the {patchwork} package using symbols such as +, / and parentheses. We first need to create some plots and save them: p_a &lt;- ggplot(dat) + aes(x = displ, y = hwy) + geom_point() p_b &lt;- ggplot(dat) + aes(x = hwy) + geom_histogram() p_c &lt;- ggplot(dat) + aes(x = drv, y = hwy) + geom_boxplot() Now that we have 3 plots saved in our environment, we can combine them. To have plots next to each other simply use the + symbol: library(patchwork) p_a + p_b + p_c ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. To display them above each other simply use the / symbol: p_a / p_b / p_c ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. And finally, to combine them above and next to each other, mix +, / and parentheses: p_a + p_b / p_c ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. (p_a + p_b) / p_c ## `stat_bin()` using `bins = 30`. Pick better value with ## `binwidth`. See more ways to combine plots with: grid.arrange() from the {gridExtra} package plot_grid() from the {cowplot} package 2.3.9.13 Flip coordinates Flipping coordinates of your plot is useful to create horizontal boxplots, or when labels of a variable are so long that they overlap each other on the x-axis. See with and without flipping coordinates below: # without flipping coordinates p1 &lt;- ggplot(dat) + aes(x = class, y = hwy) + geom_boxplot() # with flipping coordinates p2 &lt;- ggplot(dat) + aes(x = class, y = hwy) + geom_boxplot() + coord_flip() library(patchwork) p1 + p2 # left: without flipping, right: with flipping This can be done with many types of plot, not only with boxplots. For instance, if a categorical variable has many levels or the labels are long, it is usually best to flip the coordinates for a better visual: ggplot(dat) + aes(x = class) + geom_bar() + coord_flip() 2.3.9.14 Save plot The ggsave() function will save the most recent plot in your current working directory unless you specify a path to another folder: ggplot(dat) + aes(x = displ, y = hwy) + geom_point() ggsave(&quot;plot1.pdf&quot;) You can also specify the width, height and resolution (dpi) as follows: ggsave(&quot;plot1.pdf&quot;, width = 12, height = 12, units = &quot;cm&quot;, dpi = 300 ) 2.3.9.15 Managing dates If the time variable in your dataset is in date format, the {ggplot2} package recognizes the date format and automatically uses a specific type for the axis ticks. There is no time variable with a date format in our dataset, so lets create a new variable of this type thanks to the as.Date() function: dat$date &lt;- as.Date(&quot;2020-08-21&quot;) - 0:(nrow(dat) - 1) See the first 6 observations of this date variable and its class: head(dat$date) ## [1] &quot;2020-08-21&quot; &quot;2020-08-20&quot; &quot;2020-08-19&quot; &quot;2020-08-18&quot; ## [5] &quot;2020-08-17&quot; &quot;2020-08-16&quot; str(dat$date) ## Date[1:234], format: &quot;2020-08-21&quot; &quot;2020-08-20&quot; &quot;2020-08-19&quot; &quot;2020-08-18&quot; ... The new variable date is correctly specified in a date format. Most of the time, with a time variable, we want to create a line plot with the date on the X-axis and another continuous variable on the Y-axis, like the following plot for example: p &lt;- ggplot(dat) + aes(x = date, y = hwy) + geom_line() p As soon as the time variable is recognized as a date, we can use the scale_x_date() layer to change the format displayed on the X-axis. The following table shows the most frequent date formats: Run ?strptime() to see many more date formats available in R. For this example, lets add the year in addition to the unabbreviated month: p + scale_x_date(date_labels = &quot;%B %Y&quot;) It also possible to control the breaks to display on the X-axis with the date_breaks argument. For this example, lets say we want to display the day as number and the abbreviated month for each interval of 10 days: p + scale_x_date(date_breaks = &quot;10 days&quot;, date_labels = &quot;%d %b&quot;) If labels displayed on the X-axis are unreadable because they overlap each other, you can rotate them with the theme() layer and the angle argument: p + scale_x_date(date_breaks = &quot;10 days&quot;, date_labels = &quot;%d %b&quot;) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 2.4 To go further By now you have seen that {ggplot2} is a very powerful and complete package to create plots in R. This article illustrated only the tip of the iceberg, and you will find many tutorials on how to create more advanced plots and visualizations with {ggplot2} online. If you want to learn more than what is described in the present article, I highly recommend starting with: the chapters Data visualisation and Graphics for communication from the book R for Data Science from Garrett Grolemund and Hadley Wickham the book ggplot2: Elegant Graphics for Data Analysis from Hadley Wickham the book R Graphics Cookbook from Winston Chang the ggplot2 extensions guide which lists many of the packages that extend {ggplot2}. Thanks for reading. I hope this article helped you to create your first plots with the {ggplot2} package. As a reminder, for simple graphs, it is sometimes easier to draw them via the {esquisse} addin. After some time, you will quickly learn how to create them by yourselves and in no time you will be able to build complex and sophisticated data visualizations. Use the geom_jitter() layer with caution because, although it makes a plot more revealing at large scales, it also makes it slightly less accurate at small scales since some randomness is added to the points. There are (at the time of writing) 26 shapes accepted in the shape argument. See this documentation for all available shapes. "]]
